stages:
  - test
  - build
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  REGISTRY: $CI_REGISTRY
  IMAGE_NAME: $CI_REGISTRY_IMAGE

# Test Stage
test:unit:
  stage: test
  image: python:3.11
  services:
    - postgres:15
    - redis:7
  variables:
    POSTGRES_DB: itsm_test
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_HOST_AUTH_METHOD: trust
  before_script:
    - cd backend
    - pip install --upgrade pip
    - pip install -r requirements.txt
    - pip install pytest pytest-cov pytest-django
  script:
    - cp .env.example .env
    - sed -i 's/DEBUG=True/DEBUG=False/' .env
    - sed -i 's/DB_HOST=localhost/DB_HOST=postgres/' .env
    - sed -i 's/REDIS_URL=redis:\/\/localhost/REDIS_URL=redis:\/\/redis/' .env
    - python manage.py migrate
    - pytest tests/ --cov=apps --cov-report=xml --cov-report=html --junitxml=test-results.xml -v
  coverage: '/TOTAL.*\s+(\d+%)$/'
  artifacts:
    when: always
    paths:
      - backend/htmlcov
      - backend/test-results.xml
    reports:
      junit: backend/test-results.xml
      coverage_report:
        coverage_format: cobertura
        path: backend/coverage.xml
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

test:integration:
  stage: test
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - apk add --no-cache docker-compose curl
  script:
    - cd backend
    - docker-compose up -d
    - sleep 30
    - docker-compose exec -T backend python manage.py migrate
    - docker-compose exec -T backend pytest tests/ -v
    - curl -f http://localhost:8000/health/ || exit 1
  after_script:
    - cd backend
    - docker-compose down -v
  only:
    - merge_requests

test:security:
  stage: test
  image: python:3.11
  before_script:
    - pip install bandit safety
  script:
    - bandit -r backend/apps -f json -o bandit-report.json || true
    - safety check --json || true
  artifacts:
    paths:
      - bandit-report.json
    when: always

# Build Stage
build:docker:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $IMAGE_NAME:$CI_COMMIT_SHA -t $IMAGE_NAME:latest backend/
    - docker push $IMAGE_NAME:$CI_COMMIT_SHA
    - docker push $IMAGE_NAME:latest
  only:
    - main
    - develop
  retry:
    max: 2

# Deploy Stage - Staging
deploy:staging:
  stage: deploy
  image: bitnami/kubectl:latest
  environment:
    name: staging
    url: https://staging.example.com
    kubernetes:
      namespace: staging
  before_script:
    - echo $KUBE_CONFIG | base64 -d > kubeconfig.yaml
    - export KUBECONFIG=kubeconfig.yaml
  script:
    - kubectl set image deployment/itsm-api itsm-api=$IMAGE_NAME:$CI_COMMIT_SHA -n staging
    - kubectl rollout status deployment/itsm-api -n staging --timeout=5m
    - sleep 30
    - kubectl run curl-test --image=curlimages/curl --rm -it -- curl http://itsm-api/health/ || exit 1
  only:
    - develop
  when: manual

# Deploy Stage - Production
deploy:production:
  stage: deploy
  image: bitnami/kubectl:latest
  environment:
    name: production
    url: https://api.example.com
    kubernetes:
      namespace: production
  before_script:
    - echo $KUBE_CONFIG | base64 -d > kubeconfig.yaml
    - export KUBECONFIG=kubeconfig.yaml
  script:
    - kubectl set image deployment/itsm-api itsm-api=$IMAGE_NAME:$CI_COMMIT_SHA -n production
    - kubectl rollout status deployment/itsm-api -n production --timeout=10m
    - sleep 30
    - kubectl run curl-test --image=curlimages/curl --rm -it -- curl https://api.example.com/health/ || exit 1
  only:
    - main
  when: manual

# Cleanup
cleanup:registry:
  stage: deploy
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker image prune -a --force --filter "until=72h"
  only:
    - schedules
  allow_failure: true
