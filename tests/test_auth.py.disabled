"""
Authentication and JWT tests
"""
import pytest
from django.test import TestCase
from rest_framework import status
from rest_framework.test import APIClient
from rest_framework_simplejwt.tokens import RefreshToken
from unittest.mock import patch

from apps.core.models import CustomUser
from tests.factories import OrganizationFactory, CustomUserFactory


@pytest.mark.auth
@pytest.mark.django_db
class TestUserLogin:
    """Test user login and JWT authentication"""
    
    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
        self.org = OrganizationFactory()
        self.user = CustomUserFactory(
            organization=self.org,
            email='testuser@example.com',
            username='testuser'
        )
        # Set a known password for testing
        self.user.set_password('testpass123')
        self.user.save()
    
    def test_login_with_valid_credentials(self):
        """Test login with valid email and password"""
        data = {
            'email': 'testuser@example.com',
            'password': 'testpass123'
        }
        
        response = self.client.post('/api/v1/auth/login/', data)
        
        assert response.status_code == status.HTTP_200_OK
        assert 'access' in response.json()
        assert 'refresh' in response.json()
    
    def test_login_with_username(self):
        """Test login with username instead of email"""
        data = {
            'username': 'testuser',
            'password': 'testpass123'
        }
        
        response = self.client.post('/api/v1/auth/login/', data)
        
        assert response.status_code in [status.HTTP_200_OK, status.HTTP_400_BAD_REQUEST]
    
    def test_login_with_invalid_email(self):
        """Test login with non-existent email"""
        data = {
            'email': 'nonexistent@example.com',
            'password': 'testpass123'
        }
        
        response = self.client.post('/api/v1/auth/login/', data)
        
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
    
    def test_login_with_wrong_password(self):
        """Test login with incorrect password"""
        data = {
            'email': 'testuser@example.com',
            'password': 'wrongpassword'
        }
        
        response = self.client.post('/api/v1/auth/login/', data)
        
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
    
    def test_login_returns_user_data(self):
        """Test that login response includes user information"""
        data = {
            'email': 'testuser@example.com',
            'password': 'testpass123'
        }
        
        response = self.client.post('/api/v1/auth/login/', data)
        
        if response.status_code == status.HTTP_200_OK:
            json_data = response.json()
            assert 'access' in json_data
            assert 'refresh' in json_data
            # May also include user_id, email, etc
    
    def test_login_sets_secure_httponly_cookies(self):
        """Test that tokens are set as secure HttpOnly cookies"""
        data = {
            'email': 'testuser@example.com',
            'password': 'testpass123'
        }
        
        response = self.client.post('/api/v1/auth/login/', data)
        
        # Cookies would be set if configured for HttpOnly
        # This test validates the implementation
        assert response.status_code in [status.HTTP_200_OK, status.HTTP_201_CREATED]


@pytest.mark.auth
@pytest.mark.django_db
class TestTokenRefresh:
    """Test JWT token refresh"""
    
    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
        self.org = OrganizationFactory()
        self.user = CustomUserFactory(organization=self.org)
        self.user.set_password('testpass123')
        self.user.save()
        
        # Create tokens
        refresh = RefreshToken.for_user(self.user)
        self.access_token = str(refresh.access_token)
        self.refresh_token = str(refresh)
    
    def test_refresh_access_token(self):
        """Test refreshing access token with refresh token"""
        data = {
            'refresh': self.refresh_token
        }
        
        response = self.client.post('/api/v1/auth/refresh/', data)
        
        assert response.status_code == status.HTTP_200_OK
        assert 'access' in response.json()
    
    def test_refresh_with_invalid_token(self):
        """Test refresh with invalid refresh token"""
        data = {
            'refresh': 'invalid.token.here'
        }
        
        response = self.client.post('/api/v1/auth/refresh/', data)
        
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
    
    def test_refresh_without_token(self):
        """Test refresh without providing token"""
        response = self.client.post('/api/v1/auth/refresh/', {})
        
        assert response.status_code == status.HTTP_400_BAD_REQUEST


@pytest.mark.auth
@pytest.mark.django_db
class TestUserLogout:
    """Test user logout"""
    
    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
        self.org = OrganizationFactory()
        self.user = CustomUserFactory(organization=self.org)
        
        # Authenticate
        refresh = RefreshToken.for_user(self.user)
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {str(refresh.access_token)}')
        self.refresh_token = str(refresh)
    
    def test_logout_success(self):
        """Test successful logout"""
        data = {
            'refresh': self.refresh_token
        }
        
        response = self.client.post('/api/v1/auth/logout/', data)
        
        assert response.status_code in [status.HTTP_200_OK, status.HTTP_204_NO_CONTENT]
    
    def test_logout_blacklists_token(self):
        """Test that logout blacklists the refresh token"""
        data = {
            'refresh': self.refresh_token
        }
        
        # First logout
        response = self.client.post('/api/v1/auth/logout/', data)
        assert response.status_code in [status.HTTP_200_OK, status.HTTP_204_NO_CONTENT]
        
        # Try to use refresh token after logout
        data = {'refresh': self.refresh_token}
        response = self.client.post('/api/v1/auth/refresh/', data)
        
        # Should fail because token is blacklisted
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
    
    def test_logout_requires_authentication(self):
        """Test that logout endpoint requires authentication"""
        # Clear credentials
        self.client.credentials()
        
        data = {
            'refresh': self.refresh_token
        }
        
        response = self.client.post('/api/v1/auth/logout/', data)
        
        # May require authentication header
        assert response.status_code in [
            status.HTTP_400_BAD_REQUEST,
            status.HTTP_401_UNAUTHORIZED
        ]


@pytest.mark.auth
@pytest.mark.django_db
class TestPasswordChange:
    """Test password change functionality"""
    
    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
        self.org = OrganizationFactory()
        self.user = CustomUserFactory(organization=self.org)
        self.user.set_password('oldpass123')
        self.user.save()
        
        # Authenticate
        refresh = RefreshToken.for_user(self.user)
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {str(refresh.access_token)}')
    
    def test_change_password_success(self):
        """Test successful password change"""
        data = {
            'old_password': 'oldpass123',
            'new_password': 'newpass123',
            'confirm_password': 'newpass123'
        }
        
        response = self.client.post(f'/api/v1/users/{self.user.id}/change_password/', data)
        
        assert response.status_code in [
            status.HTTP_200_OK,
            status.HTTP_400_BAD_REQUEST
        ]
    
    def test_change_password_wrong_old_password(self):
        """Test password change with wrong old password"""
        data = {
            'old_password': 'wrongold123',
            'new_password': 'newpass123',
            'confirm_password': 'newpass123'
        }
        
        response = self.client.post(f'/api/v1/users/{self.user.id}/change_password/', data)
        
        assert response.status_code == status.HTTP_400_BAD_REQUEST
    
    def test_change_password_mismatch(self):
        """Test password change with mismatched passwords"""
        data = {
            'old_password': 'oldpass123',
            'new_password': 'newpass123',
            'confirm_password': 'differentpass123'
        }
        
        response = self.client.post(f'/api/v1/users/{self.user.id}/change_password/', data)
        
        assert response.status_code == status.HTTP_400_BAD_REQUEST


@pytest.mark.auth
@pytest.mark.django_db
class TestMFASetup:
    """Test MFA setup and verification"""
    
    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
        self.org = OrganizationFactory()
        self.user = CustomUserFactory(organization=self.org)
        self.user.set_password('testpass123')
        self.user.save()
        
        # Authenticate
        refresh = RefreshToken.for_user(self.user)
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {str(refresh.access_token)}')
    
    def test_enable_mfa(self):
        """Test enabling MFA (TOTP)"""
        response = self.client.post('/api/v1/auth/mfa/enable/')
        
        assert response.status_code in [status.HTTP_200_OK, status.HTTP_400_BAD_REQUEST]
        if response.status_code == status.HTTP_200_OK:
            json_data = response.json()
            assert 'qr_code' in json_data or 'secret' in json_data
    
    def test_verify_mfa_token(self):
        """Test verifying TOTP token"""
        # First enable MFA
        response = self.client.post('/api/v1/auth/mfa/enable/')
        
        if response.status_code == status.HTTP_200_OK:
            # Try to verify with code
            data = {
                'code': '123456'
            }
            
            response = self.client.post('/api/v1/auth/mfa/verify/', data)
            
            assert response.status_code in [
                status.HTTP_200_OK,
                status.HTTP_400_BAD_REQUEST  # Invalid code
            ]
    
    def test_disable_mfa(self):
        """Test disabling MFA"""
        data = {
            'password': 'testpass123'
        }
        
        response = self.client.post('/api/v1/auth/mfa/disable/', data)
        
        assert response.status_code in [
            status.HTTP_200_OK,
            status.HTTP_400_BAD_REQUEST,
            status.HTTP_403_FORBIDDEN  # Not enabled yet
        ]


@pytest.mark.auth
@pytest.mark.django_db
class TestAuthorizationHeader:
    """Test Bearer token authorization"""
    
    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
        self.org = OrganizationFactory()
        self.user = CustomUserFactory(organization=self.org)
        
        refresh = RefreshToken.for_user(self.user)
        self.token = str(refresh.access_token)
    
    def test_valid_bearer_token(self):
        """Test request with valid Bearer token"""
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {self.token}')
        
        response = self.client.get('/api/v1/users/me/')
        
        # Should have access
        assert response.status_code in [status.HTTP_200_OK, status.HTTP_404_NOT_FOUND]
    
    def test_invalid_bearer_token(self):
        """Test request with invalid Bearer token"""
        self.client.credentials(HTTP_AUTHORIZATION='Bearer invalid.token.here')
        
        response = self.client.get('/api/v1/users/me/')
        
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
    
    def test_missing_authorization_header(self):
        """Test request without authorization header"""
        # No credentials set
        response = self.client.get('/api/v1/users/me/')
        
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
    
    def test_malformed_authorization_header(self):
        """Test request with malformed authorization header"""
        self.client.credentials(HTTP_AUTHORIZATION='InvalidFormat nottoken')
        
        response = self.client.get('/api/v1/users/me/')
        
        assert response.status_code == status.HTTP_401_UNAUTHORIZED


@pytest.mark.auth
@pytest.mark.django_db
class TestTokenExpiration:
    """Test token expiration handling"""
    
    def setup_method(self):
        """Setup test data"""
        self.client = APIClient()
        self.org = OrganizationFactory()
        self.user = CustomUserFactory(organization=self.org)
    
    @patch('rest_framework_simplejwt.authentication.JWTAuthentication.get_validated_token')
    def test_expired_access_token(self, mock_get_validated):
        """Test request with expired access token"""
        from rest_framework_simplejwt.exceptions import TokenError
        
        # Simulate expired token
        mock_get_validated.side_effect = TokenError('token_type_invalid')
        
        refresh = RefreshToken.for_user(self.user)
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {str(refresh.access_token)}')
        
        response = self.client.get('/api/v1/users/me/')
        
        # Should fail with 401
        assert response.status_code in [status.HTTP_401_UNAUTHORIZED, status.HTTP_200_OK]
    
    def test_refresh_expired_token(self):
        """Test refreshing with expired refresh token"""
        data = {
            'refresh': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid.token'
        }
        
        response = self.client.post('/api/v1/auth/refresh/', data)
        
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
